{"version":3,"sources":["/src/pc/1.9/chunk.js"],"names":["w","l","h","BUFFER_SIZE","ProtoDef","require","readUInt4LE","writeUInt4LE","module","exports","loader","mcVersion","Block","longToByte","buffer","offset","typeArgs","results","read","type","value","Math","ceil","size","write","sizeOf","p","Chunk","packingProtocol","addType","exists","val","undefined","getArrayPosition","pos","x","z","y","getBlockCursor","getBlockLightCursor","getSkyLightCursor","getBiomeCursor","data","Buffer","fill","iniFunc","skylight","light","biome","n","block","writeUInt16LE","metadata","skyLight","writeUInt8","id","getBlockType","getBiome","getBlockData","getBlockLight","getSkyLight","setBlockType","setBlockData","setBiome","setSkyLight","setBlockLight","r","g","b","cursor","readUInt16LE","readUInt8","outputBuffer","alloc","chunkBlocks","blockLightStart","skyLightStart","biomestart","chunkapp","createPacketBuffer","bitsPerBlock","palette","dataArray","packBlockData","slice","blockLight","concat","ret","rawdata","blockCount","resultantBuffer","reversedblockdata","reverseBits","startbit","startbyte","floor","existingdata","readUInt32BE","localbit","aligneddata","newdata","writeUInt32BE","jumbledBuffer","length","longleftjumbled","longrightjumbled","writeInt32BE","datau","storage","i","bitMap","unpackeddata","unpackChunkData","isBuffer","Error","chunk","newBuffer","blocksAddition","blocklightsAddition","skylightsAddition","readSection","eatPackedBlockLongs","copy","section","e","message","field","rawBuffer","unjumbledBuffer","localBit","bit","targetbyte","datatarget","paletteid","palettedata"],"mappings":"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","file":"../../../pc/1.9/chunk.js","sourcesContent":["const w = 16;\nconst l = 16;\nconst h = 256;\n\nconst BUFFER_SIZE = (w * l * h * 3) + w * l;\n\nconst ProtoDef = require('protodef').ProtoDef;\nvar { readUInt4LE, writeUInt4LE } = require('uint4');\n\nmodule.exports = loader;\n\nfunction loader(mcVersion) {\n  Block = require('prismarine-block')(mcVersion);\n\n  // MC counts the longs, protodef wants the bytes. This is responsible for that conversion.\n  let longToByte = [\n    function(buffer, offset, typeArgs) { //readLongToByte\n      var results = this.read(buffer, offset, typeArgs.type, {});\n      return {\n        value: Math.ceil(results.value * 8),\n        size: results.size\n      };\n    },\n    function(value, buffer, offset, typeArgs) { //writeLongToByte\n      return this.write(value / 8, buffer, offset, typeArgs.type, {});\n    },\n    function(value, typeArgs) { //sizeOfLongToByte\n      return this.sizeOf(value / 8, typeArgs.type, {});\n    }\n  ];\n\n  let p = [\"container\", [{\n      \"name\": \"bitsPerBlock\",\n      \"type\": \"u8\"\n    },\n    {\n      \"name\": \"palette\",\n      \"type\": [\"array\", {\n        \"type\": \"varint\",\n        \"countType\": \"varint\"\n      }]\n    },\n    {\n      \"name\": \"dataArray\",\n      \"type\": [\"buffer\", {\n        \"countType\": \"longToByte\",\n        \"countTypeArgs\": {\n          \"type\": \"varint\"\n        }\n      }]\n    },\n    {\n      \"name\": \"blockLight\",\n      \"type\": [\"buffer\", {\n        \"count\": 16 * 16 * 16 / 2\n      }]\n    },\n    {\n      \"name\": \"skyLight\",\n      \"type\": [\"buffer\", {\n        \"count\": 16 * 16 * 16 / 2\n      }]\n    }\n  ]];\n\n  Chunk.packingProtocol = new ProtoDef();\n  Chunk.packingProtocol.addType('longToByte', longToByte);\n  Chunk.packingProtocol.addType('section', p);\n\n\n  Chunk.w = w;\n  Chunk.l = l;\n  Chunk.h = h;\n  Chunk.BUFFER_SIZE = BUFFER_SIZE;\n  return Chunk;\n}\n\nvar Block;\n\nvar exists = function(val) {\n  return val !== undefined;\n};\n\n\nvar getArrayPosition = function(pos) {\n  return pos.x + w * (pos.z + l * pos.y);\n};\n\nvar getBlockCursor = function(pos) {\n  return getArrayPosition(pos) * 2.0;\n};\n\nvar getBlockLightCursor = function(pos) {\n  return getArrayPosition(pos) * 0.5 + w * l * h * 2;\n};\n\nvar getSkyLightCursor = function(pos) {\n  return getArrayPosition(pos) * 0.5 + w * l * h / 2 * 5;\n};\n\nvar getBiomeCursor = function(pos) {\n  return (w * l * h * 3) + (pos.z * w) + pos.x;\n};\n\n\nclass Chunk {\n\n  constructor() {\n    this.data = new Buffer(BUFFER_SIZE);\n    this.data.fill(0);\n  }\n\n  initialize(iniFunc) {\n    const skylight = w * l * h / 2 * 5;\n    const light = w * l * h * 2;\n    let biome = (w * l * h * 3) - 1;\n    let n = 0;\n    for (let y = 0; y < h; y++) {\n      for (let z = 0; z < w; z++) {\n        for (let x = 0; x < l; x++, n++) {\n          if (y == 0)\n            biome++;\n          const block = iniFunc(x, y, z, n);\n          if (block == null)\n            continue;\n          this.data.writeUInt16LE(block.type << 4 | block.metadata, n * 2);\n          writeUInt4LE(this.data, block.light, n * 0.5 + light);\n          writeUInt4LE(this.data, block.skyLight, n * 0.5 + skylight);\n          if (y == 0) {\n            this.data.writeUInt8(block.biome.id || 0, biome);\n          }\n        }\n      }\n    }\n  }\n\n  getBlock(pos) {\n    var block = new Block(this.getBlockType(pos), this.getBiome(pos), this.getBlockData(pos));\n    block.light = this.getBlockLight(pos);\n    block.skyLight = this.getSkyLight(pos);\n    return block;\n  }\n\n  setBlock(pos, block) {\n    if (exists(block.type))\n      this.setBlockType(pos, block.type);\n    if (exists(block.metadata))\n      this.setBlockData(pos, block.metadata);\n    if (exists(block.biome))\n      this.setBiome(pos, block.biome.id);\n    if (exists(block.skyLight))\n      this.setSkyLight(pos, block.skyLight);\n    if (exists(block.light))\n      this.setBlockLight(pos, block.light);\n  }\n\n  getBiomeColor(pos) {\n    // polyfill\n    return {\n      r: 0,\n      g: 0,\n      b: 0\n    }\n  }\n\n  setBiomeColor(pos, r, g, b) {\n    // polyfill\n  }\n\n  getBlockType(pos) {\n    var cursor = getBlockCursor(pos);\n    return this.data.readUInt16LE(cursor) >> 4;\n  }\n\n  getBlockData(pos) {\n    var cursor = getBlockCursor(pos);\n    return this.data.readUInt16LE(cursor) & 15;\n  }\n\n  getBlockLight(pos) {\n    var cursor = getBlockLightCursor(pos);\n    return readUInt4LE(this.data, cursor);\n  }\n\n  getSkyLight(pos) {\n    var cursor = getSkyLightCursor(pos);\n    return readUInt4LE(this.data, cursor);\n  }\n\n  getBiome(pos) {\n    var cursor = getBiomeCursor(pos);\n    return this.data.readUInt8(cursor);\n  }\n\n  setBlockType(pos, id) {\n    var cursor = getBlockCursor(pos);\n    var data = this.getBlockData(pos);\n    this.data.writeUInt16LE((id << 4) | data, cursor);\n  }\n\n  setBlockData(pos, data) {\n    var cursor = getBlockCursor(pos);\n    var id = this.getBlockType(pos);\n    this.data.writeUInt16LE((id << 4) | data, cursor);\n  }\n\n  setBlockLight(pos, light) {\n    var cursor = getBlockLightCursor(pos);\n    writeUInt4LE(this.data, light, cursor);\n  }\n\n  setSkyLight(pos, light) {\n    var cursor = getSkyLightCursor(pos);\n    writeUInt4LE(this.data, light, cursor);\n  }\n\n  setBiome(pos, biome) {\n    var cursor = getBiomeCursor(pos);\n    this.data.writeUInt8(biome, cursor);\n  }\n\n  dump() {\n    //OLD/INTERNAL FORMAT:\n    //The first w*l*h*2 bytes are blocks, each of which are shorts.\n    //After that, the first w*l*h*0.5 bytes are block-light-levels, each half-bytes.\n    //Next, the first w*l*h*0.5 bytes are sky-light-levels, each half-bytes.\n    //Finally, the next w*l bytes are biomes.\n\n    let outputBuffer = Buffer.alloc(0);\n    let chunkBlocks = Chunk.l * Chunk.w * 16;\n    let blockLightStart = Chunk.l * Chunk.w * Chunk.h * 2;\n    let skyLightStart = blockLightStart + Chunk.l * Chunk.w * Chunk.h / 2;\n    let biomestart = skyLightStart + Chunk.l * Chunk.w * Chunk.h / 2;\n\n\t\n\n\n    for (let y = 0; y < 16; y++) {\n      let chunkapp = Chunk.packingProtocol.createPacketBuffer('section', {\n        bitsPerBlock: 13,\n        palette: [],\n        dataArray: this.packBlockData(this.data.slice(y * chunkBlocks * 2, (y + 1) * chunkBlocks * 2), 13),\n        blockLight: this.data.slice(blockLightStart + y * chunkBlocks / 2, blockLightStart + (y + 1) * chunkBlocks / 2),\n        skyLight: this.data.slice(skyLightStart + y * chunkBlocks / 2, skyLightStart + (y + 1) * chunkBlocks / 2),\n      });\n      outputBuffer = Buffer.concat([outputBuffer, chunkapp]);\n    }\n\n    let ret = Buffer.concat([outputBuffer, this.data.slice(biomestart, biomestart + Chunk.l * Chunk.w)]);\n    //console.log(ret.length);\n    return ret;\n  }\n  packBlockData(rawdata, bitsPerBlock) {\n    let blockCount = Chunk.l * Chunk.w * 16;\n    let resultantBuffer = Buffer.alloc(blockCount * bitsPerBlock / 8 + 4);\n    //We have to write very slightly past the end of the file, so we tack on 4 bytes.\n    //We'll drop them at the end.\n    for (let block = 0; block < blockCount; block++) {\n      //Gather and reverse the block data\n      let reversedblockdata = this.reverseBits(rawdata.readUInt16LE(block * 2), 16) >>> 3;\n      //Determine the start-bit for the block.\n      let startbit = block * bitsPerBlock;\n      //Determine the start-byte for that bit.\n      let startbyte = Math.floor(startbit / 8);\n      //Read 4 bytes after that start byte.\n      let existingdata = resultantBuffer.readUInt32BE(startbyte);\n      //if (reversedblockdata == 0b0000100000000000)\n      //\tconsole.log(\"existing: \" + this.padbin(existingdata, 32));\n\t  //Where are we writing to, in the current bit?\n      let localbit = startbit % 8;\n      //Bit-shift the raw data into alignment:\n      let aligneddata = reversedblockdata << (32 - bitsPerBlock - localbit);\n      //if (reversedblockdata == 0b0000100000000000)\n      //\tconsole.log(\"aligned: \" + this.padbin(aligneddata, 32));\n      //Paste aligned data onto existing data\n      let newdata = existingdata | aligneddata;\n      //Write data back into buffer:\n      resultantBuffer.writeUInt32BE(newdata>>>0, startbyte);\n    }\n\n    //now, we jumble: (and we're sure to drop those extra 4 bytes!)\n    let jumbledBuffer = Buffer.alloc(resultantBuffer.length - 4);\n    for (let l = 0; l < jumbledBuffer.length; l += 8) {\n      //Load the long\n      let longleftjumbled = resultantBuffer.readUInt32BE(l);\n      let longrightjumbled = resultantBuffer.readUInt32BE(l + 4);\n      //Write in reverse order -- flip bits by using little endian.\n      jumbledBuffer.writeInt32BE(this.reverseBits(longrightjumbled, 32), l);\n      jumbledBuffer.writeInt32BE(this.reverseBits(longleftjumbled, 32), l + 4);\n    }\n    return jumbledBuffer;\n  }\n  \n  reverseBits(data, n) {\n   let datau = data >>> 0;//Coerce unsigned.\n   let storage = 0;\n   for (let i = 0; i < n; i++) {\n     storage = storage | (datau & 1);\n     if (i != n - 1) {\n       storage = storage << 1;\n       datau = datau >>> 1;\n     }\n   }\n   return storage;\n }\n\n  /*Debuggery\n  padbin(num, len=32) {\n    var s = (num >>> 0).toString(2);\n    while (s.length < len) s = \"0\" + s;\n    return s;\n   }\n   */\n\n  load(data, bitMap=0xFFFF) {\n    let unpackeddata = this.unpackChunkData(data, bitMap);\n    if (!Buffer.isBuffer(unpackeddata))\n      throw (new Error('Data must be a buffer'));\n    if (unpackeddata.length != BUFFER_SIZE)\n      throw (new Error('Data buffer not correct size (was ' + unpackeddata.length + ', expected ' + BUFFER_SIZE + ')'));\n    this.data = unpackeddata;\n  }\n\n  unpackChunkData(chunk, bitMap) {\n    let offset = 0;\n    let chunkBlocks = Chunk.l * Chunk.w * 16;\n    let blockLightStart = Chunk.l * Chunk.w * Chunk.h * 2;\n    let skyLightStart = blockLightStart + Chunk.l * Chunk.w * Chunk.h / 2;\n    let biomestart = skyLightStart + Chunk.l * Chunk.w * Chunk.h / 2;\n    \n    let newBuffer = Buffer.alloc(BUFFER_SIZE);\n\n    for (let y = 0; y < 16; y++) {\n      let blocksAddition;\n      let blocklightsAddition;\n      let skylightsAddition;\n      if (((bitMap >> y) & 1) == 1) {\n        const {\n          size,\n          value\n        } = this.readSection(chunk.slice(offset));\n        offset += size;\n        blocksAddition = this.eatPackedBlockLongs(value.dataArray, value.palette, value.bitsPerBlock);\n        blocklightsAddition = value.blockLight;\n        skylightsAddition = value.skyLight;\n      } else { //If a chunk is skipped, we'll just fill with existing data.\n        blocksAddition = this.data.slice(y * chunkBlocks * 2, (y + 1) * chunkBlocks * 2);\n        blocklightsAddition = this.data.slice(blockLightStart + y * chunkBlocks / 2, blockLightStart + (y + 1) * chunkBlocks / 2);\n        skylightsAddition = this.data.slice(skyLightStart + y * chunkBlocks / 2, skyLightStart + (y + 1) * chunkBlocks / 2);\n      }\n      blocksAddition.copy(newBuffer, y * chunkBlocks*2);\n      blocklightsAddition.copy(newBuffer, blockLightStart + y * chunkBlocks/2);\n      skylightsAddition.copy(newBuffer, skyLightStart + y * chunkBlocks/2);\n    }\n    if (bitMap == 0xFFFF){\n      chunk.slice(chunk.length - 256).copy(newBuffer, biomestart);\n    }\n    return newBuffer;\n  }\n\n  readSection(section) {\n    try {\n      return Chunk.packingProtocol.read(section, 0, 'section', {});\n    } catch (e) {\n      e.message = `Read error for ${e.field} : ${e.message}`;\n      throw e;\n    }\n  }\n\n  \n  //Simplified eatPackedBlockLongs Algorithm\n  eatPackedBlockLongs(rawBuffer, palette, bitsPerBlock) {\n    //The critical problem is that the internal order of each long is opposite to the organizational order of the longs\n    //This is easily fixed by flipping the order of the longs.\n    //Therefore, we will read 4 bytes at a time, bit-flip them, and write them into a new buffer.\n    //From there, the old algorithm for reading will work just fine, we don't even have to consider the existence of the longs anymore.\n    //A major side-effect, though, is that all of the internal block-datas will be flipped, so we have to flip them again before extracting data.\n    let unjumbledBuffer = Buffer.alloc(rawBuffer.length);\n    for (let l = 0; l < rawBuffer.length; l += 8) {\n      //Load the long\n      \n      let longleftjumbled = rawBuffer.readUInt32BE(l);\n      let longrightjumbled = rawBuffer.readUInt32BE(l + 4);\n      //Write in reverse order\n      \n      unjumbledBuffer.writeInt32BE(this.reverseBits(longrightjumbled, 32), l);\n      unjumbledBuffer.writeInt32BE(this.reverseBits(longleftjumbled, 32), l + 4);\n    }\n\n\n    let blockCount = unjumbledBuffer.length * 8 / bitsPerBlock;\n    let resultantBuffer = Buffer.alloc(blockCount * 2);\n    let localBit = 0;\n\n    for (let block = 0; block < blockCount; block++) {\n      //Determine the start-bit for the block.\n      let bit = block * bitsPerBlock;\n      //Determine the start-byte for that bit.\n      let targetbyte = Math.floor(bit / 8);\n\n      //Read a 32-bit section surrounding the targeted block\n\n      let datatarget = unjumbledBuffer.readUInt32BE(targetbyte, true);\n      //console.log(\":\");\n      //console.log(this.padbin(aligneddata,32));\n\n      //Determine the start bit local to the datatarget.\n      let localbit = bit % 8;\n\n      //Chop off uninteresting bits, then shift interesting region to the end of the bit-buffer. Reverse the bits when done\n      \n      let paletteid = this.reverseBits((datatarget << localbit) >>> (32 - bitsPerBlock), bitsPerBlock);\n\t  \n      //console.log(this.padbin(paletteid, 32));\n\n\n      //Grab the data from the palette\n      let palettedata = paletteid;\n      if (palette.length != 0)\n        palettedata = palette[paletteid];\n      let data = palettedata & 0b1111;\n      let id = palettedata >>> 4;\n      resultantBuffer.writeUInt16LE((id << 4) | data, block * 2);\n    }\n    return resultantBuffer;\n  }\n}"]}