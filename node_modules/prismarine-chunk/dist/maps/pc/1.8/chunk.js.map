{"version":3,"sources":["/src/pc/1.8/chunk.js"],"names":["Section","require","Vec3","w","l","sh","sectionCount","h","SECTION_SIZE","BIOME_SIZE","BUFFER_SIZE","module","exports","loader","mcVersion","Block","Chunk","exists","val","undefined","getBiomeCursor","pos","z","x","posInSection","modulus","parseBitMap","bitMap","chunkIncluded","Array","chunkCount","y","sections","i","biome","Buffer","fill","iniFunc","initialize","n","block","writeUInt8","id","getBlockType","getBiome","getBlockData","light","getBlockLight","skyLight","getSkyLight","type","setBlockType","metadata","setBlockData","setBiome","setSkyLight","setBlockLight","r","g","b","_getSection","cursor","readUInt8","data","bufferLength","buffer","offset","offsetLight","offsetSkyLight","dump","copy","isBuffer","Error","sectionBuffer","load","length"],"mappings":"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","file":"../../../pc/1.8/chunk.js","sourcesContent":["const Section=require('./section');\nconst Vec3 = require(\"vec3\").Vec3;\n\nconst w=Section.w;\nconst l=Section.l;\nconst sh=Section.sh;//section height\nconst sectionCount=16;\nconst h=sh*sectionCount;\n\nconst SECTION_SIZE=Section.SECTION_SIZE;\nconst BIOME_SIZE=w*l;\nconst BUFFER_SIZE = SECTION_SIZE*sectionCount + BIOME_SIZE; // max\n\nmodule.exports = loader;\n\nfunction loader(mcVersion) {\n  Block = require('prismarine-block')(mcVersion);\n  Chunk.w=w;\n  Chunk.l=l;\n  Chunk.h=h;\n  Chunk.BUFFER_SIZE=BUFFER_SIZE;\n  return Chunk;\n}\n\nlet Block;\n\nconst exists = function (val) {\n  return val !== undefined;\n};\n\nconst getBiomeCursor = function (pos) {\n  return (pos.z * w) + pos.x;\n};\n\nfunction posInSection(pos) {\n  return pos.modulus(new Vec3(w,l,sh))\n}\n\nfunction parseBitMap(bitMap) {\n  const chunkIncluded = new Array(sectionCount);\n  let chunkCount=0;\n  for(let y = 0; y < sectionCount; ++y) {\n    chunkIncluded[y] = bitMap & (1 << y);\n    if(chunkIncluded[y]) chunkCount++;\n  }\n  return {chunkIncluded,chunkCount};\n}\n\nclass Chunk {\n\n  constructor() {\n    this.sections=new Array(sectionCount);\n    for(let i=0;i<sectionCount;i++)\n      this.sections[i]=new Section()\n    this.biome=new Buffer(BIOME_SIZE);\n    this.biome.fill(0);\n  }\n\n  initialize(iniFunc) {\n    let biome=-1;\n    for(let i=0;i<sectionCount;i++) {\n      this.sections.initialize((x,y,z,n) => {\n        let block= iniFunc(x,y%sh,z,n);\n        if(block==null)\n          return;\n        if(y==0) {\n          biome++;\n          this.biome.writeUInt8(block.biome.id || 0, biome);\n        }\n      });\n    }\n  }\n\n  getBlock(pos) {\n    const block = new Block(this.getBlockType(pos), this.getBiome(pos), this.getBlockData(pos));\n    block.light = this.getBlockLight(pos);\n    block.skyLight = this.getSkyLight(pos);\n    return block;\n  }\n\n  setBlock(pos, block) {\n    if (exists(block.type))\n      this.setBlockType(pos, block.type);\n    if (exists(block.metadata))\n      this.setBlockData(pos, block.metadata);\n    if (exists(block.biome))\n      this.setBiome(pos, block.biome.id);\n    if (exists(block.skyLight))\n      this.setSkyLight(pos, block.skyLight);\n    if (exists(block.light))\n      this.setBlockLight(pos, block.light);\n  }\n\n  getBiomeColor(pos) {\n    return {\n      r: 0,\n      g: 0,\n      b: 0\n    }\n  }\n\n  setBiomeColor(pos, r, g, b) {\n\n  }\n\n  _getSection(pos) {\n    return this.sections[pos.y>>4];\n  }\n\n  getBlockType(pos) {\n    return this._getSection(pos).getBlockType(posInSection(pos));\n  }\n\n  getBlockData(pos) {\n    return this._getSection(pos).getBlockData(posInSection(pos));\n  }\n\n  getBlockLight(pos) {\n    return this._getSection(pos).getBlockLight(posInSection(pos));\n  }\n\n  getSkyLight(pos) {\n    return this._getSection(pos).getSkyLight(posInSection(pos));\n  }\n\n  getBiome(pos) {\n    const cursor = getBiomeCursor(pos);\n    return this.biome.readUInt8(cursor);\n  }\n\n  setBlockType(pos, id) {\n    this._getSection(pos).setBlockType(posInSection(pos),id);\n  }\n\n  setBlockData(pos, data) {\n    this._getSection(pos).setBlockData(posInSection(pos),data);\n  }\n\n  setBlockLight(pos, light) {\n    this._getSection(pos).setBlockLight(posInSection(pos),light);\n  }\n\n  setSkyLight(pos, light) {\n    this._getSection(pos).setSkyLight(posInSection(pos),light);\n  }\n\n  setBiome(pos, biome) {\n    const cursor = getBiomeCursor(pos);\n    this.biome.writeUInt8(biome, cursor);\n  }\n\n  dump(bitMap=0xFFFF) {\n    const {chunkIncluded,chunkCount}=parseBitMap(bitMap);\n    const bufferLength=chunkCount*SECTION_SIZE+BIOME_SIZE;\n    const buffer=new Buffer(bufferLength);\n    let offset=0;\n    let offsetLight=w*l*sectionCount*chunkCount*2;\n    let offsetSkyLight=w*l*sectionCount*chunkCount/2*5;\n    for(let i=0;i<sectionCount;i++) {\n      if(chunkIncluded[i]) {\n        offset += this.sections[i].dump().copy(buffer, offset, 0, w * l * sh * 2);\n        offsetLight += this.sections[i].dump().copy(buffer, offsetLight,w * l * sh*2, w * l * sh*2+w * l * sh/2);\n        offsetSkyLight += this.sections[i].dump().copy(buffer, offsetSkyLight,w * l * sh/2*5, w * l * sh/2*5+w * l * sh/2);\n\n      }\n    }\n    this.biome.copy(buffer,w * l * sectionCount*chunkCount * 3);\n    return buffer;\n  }\n\n\n  load(data,bitMap=0xFFFF) {\n    if (!Buffer.isBuffer(data))\n      throw(new Error('Data must be a buffer'));\n    const {chunkIncluded,chunkCount}=parseBitMap(bitMap);\n    let offset=0;\n    let offsetLight=w*l*sectionCount*chunkCount*2;\n    let offsetSkyLight=w*l*sectionCount*chunkCount/2*5;\n    for(let i=0;i<sectionCount;i++) {\n      if(chunkIncluded[i]) {\n        const sectionBuffer=new Buffer(SECTION_SIZE);\n        offset+=data.copy(sectionBuffer,0,offset,offset+w*l*sh*2);\n        offsetLight+=data.copy(sectionBuffer,w*l*sh*2,offsetLight,offsetLight+w*l*sh/2);\n        offsetSkyLight+=data.copy(sectionBuffer,w*l*sh*5/2,offsetLight,offsetSkyLight+w*l*sh/2);\n        this.sections[i].load(sectionBuffer);\n      }\n    }\n    data.copy(this.biome,w*l*sectionCount*chunkCount*3);\n\n\n    if (data.length != SECTION_SIZE*chunkCount+w*l)\n      throw(new Error(`Data buffer not correct size \\(was ${data.length}, expected ${BUFFER_SIZE}\\)`));\n  }\n}\n\n"]}