'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Section = require('./section');
var Vec3 = require("vec3").Vec3;

var w = Section.w;
var l = Section.l;
var sh = Section.sh; //section height
var sectionCount = 16;
var h = sh * sectionCount;

var SECTION_SIZE = Section.SECTION_SIZE;
var BIOME_SIZE = w * l;
var BUFFER_SIZE = SECTION_SIZE * sectionCount + BIOME_SIZE; // max

module.exports = loader;

function loader(mcVersion) {
  Block = require('prismarine-block')(mcVersion);
  Chunk.w = w;
  Chunk.l = l;
  Chunk.h = h;
  Chunk.BUFFER_SIZE = BUFFER_SIZE;
  return Chunk;
}

var Block = void 0;

var exists = function exists(val) {
  return val !== undefined;
};

var getBiomeCursor = function getBiomeCursor(pos) {
  return pos.z * w + pos.x;
};

function posInSection(pos) {
  return pos.modulus(new Vec3(w, l, sh));
}

function parseBitMap(bitMap) {
  var chunkIncluded = new Array(sectionCount);
  var chunkCount = 0;
  for (var y = 0; y < sectionCount; ++y) {
    chunkIncluded[y] = bitMap & 1 << y;
    if (chunkIncluded[y]) chunkCount++;
  }
  return { chunkIncluded: chunkIncluded, chunkCount: chunkCount };
}

var Chunk = function () {
  function Chunk() {
    _classCallCheck(this, Chunk);

    this.sections = new Array(sectionCount);
    for (var i = 0; i < sectionCount; i++) {
      this.sections[i] = new Section();
    }this.biome = new Buffer(BIOME_SIZE);
    this.biome.fill(0);
  }

  _createClass(Chunk, [{
    key: 'initialize',
    value: function initialize(iniFunc) {
      var _this = this;

      var biome = -1;
      for (var i = 0; i < sectionCount; i++) {
        this.sections.initialize(function (x, y, z, n) {
          var block = iniFunc(x, y % sh, z, n);
          if (block == null) return;
          if (y == 0) {
            biome++;
            _this.biome.writeUInt8(block.biome.id || 0, biome);
          }
        });
      }
    }
  }, {
    key: 'getBlock',
    value: function getBlock(pos) {
      var block = new Block(this.getBlockType(pos), this.getBiome(pos), this.getBlockData(pos));
      block.light = this.getBlockLight(pos);
      block.skyLight = this.getSkyLight(pos);
      return block;
    }
  }, {
    key: 'setBlock',
    value: function setBlock(pos, block) {
      if (exists(block.type)) this.setBlockType(pos, block.type);
      if (exists(block.metadata)) this.setBlockData(pos, block.metadata);
      if (exists(block.biome)) this.setBiome(pos, block.biome.id);
      if (exists(block.skyLight)) this.setSkyLight(pos, block.skyLight);
      if (exists(block.light)) this.setBlockLight(pos, block.light);
    }
  }, {
    key: 'getBiomeColor',
    value: function getBiomeColor(pos) {
      return {
        r: 0,
        g: 0,
        b: 0
      };
    }
  }, {
    key: 'setBiomeColor',
    value: function setBiomeColor(pos, r, g, b) {}
  }, {
    key: '_getSection',
    value: function _getSection(pos) {
      return this.sections[pos.y >> 4];
    }
  }, {
    key: 'getBlockType',
    value: function getBlockType(pos) {
      return this._getSection(pos).getBlockType(posInSection(pos));
    }
  }, {
    key: 'getBlockData',
    value: function getBlockData(pos) {
      return this._getSection(pos).getBlockData(posInSection(pos));
    }
  }, {
    key: 'getBlockLight',
    value: function getBlockLight(pos) {
      return this._getSection(pos).getBlockLight(posInSection(pos));
    }
  }, {
    key: 'getSkyLight',
    value: function getSkyLight(pos) {
      return this._getSection(pos).getSkyLight(posInSection(pos));
    }
  }, {
    key: 'getBiome',
    value: function getBiome(pos) {
      var cursor = getBiomeCursor(pos);
      return this.biome.readUInt8(cursor);
    }
  }, {
    key: 'setBlockType',
    value: function setBlockType(pos, id) {
      this._getSection(pos).setBlockType(posInSection(pos), id);
    }
  }, {
    key: 'setBlockData',
    value: function setBlockData(pos, data) {
      this._getSection(pos).setBlockData(posInSection(pos), data);
    }
  }, {
    key: 'setBlockLight',
    value: function setBlockLight(pos, light) {
      this._getSection(pos).setBlockLight(posInSection(pos), light);
    }
  }, {
    key: 'setSkyLight',
    value: function setSkyLight(pos, light) {
      this._getSection(pos).setSkyLight(posInSection(pos), light);
    }
  }, {
    key: 'setBiome',
    value: function setBiome(pos, biome) {
      var cursor = getBiomeCursor(pos);
      this.biome.writeUInt8(biome, cursor);
    }
  }, {
    key: 'dump',
    value: function dump() {
      var bitMap = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0xFFFF;

      var _parseBitMap = parseBitMap(bitMap),
          chunkIncluded = _parseBitMap.chunkIncluded,
          chunkCount = _parseBitMap.chunkCount;

      var bufferLength = chunkCount * SECTION_SIZE + BIOME_SIZE;
      var buffer = new Buffer(bufferLength);
      var offset = 0;
      var offsetLight = w * l * sectionCount * chunkCount * 2;
      var offsetSkyLight = w * l * sectionCount * chunkCount / 2 * 5;
      for (var i = 0; i < sectionCount; i++) {
        if (chunkIncluded[i]) {
          offset += this.sections[i].dump().copy(buffer, offset, 0, w * l * sh * 2);
          offsetLight += this.sections[i].dump().copy(buffer, offsetLight, w * l * sh * 2, w * l * sh * 2 + w * l * sh / 2);
          offsetSkyLight += this.sections[i].dump().copy(buffer, offsetSkyLight, w * l * sh / 2 * 5, w * l * sh / 2 * 5 + w * l * sh / 2);
        }
      }
      this.biome.copy(buffer, w * l * sectionCount * chunkCount * 3);
      return buffer;
    }
  }, {
    key: 'load',
    value: function load(data) {
      var bitMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0xFFFF;

      if (!Buffer.isBuffer(data)) throw new Error('Data must be a buffer');

      var _parseBitMap2 = parseBitMap(bitMap),
          chunkIncluded = _parseBitMap2.chunkIncluded,
          chunkCount = _parseBitMap2.chunkCount;

      var offset = 0;
      var offsetLight = w * l * sectionCount * chunkCount * 2;
      var offsetSkyLight = w * l * sectionCount * chunkCount / 2 * 5;
      for (var i = 0; i < sectionCount; i++) {
        if (chunkIncluded[i]) {
          var sectionBuffer = new Buffer(SECTION_SIZE);
          offset += data.copy(sectionBuffer, 0, offset, offset + w * l * sh * 2);
          offsetLight += data.copy(sectionBuffer, w * l * sh * 2, offsetLight, offsetLight + w * l * sh / 2);
          offsetSkyLight += data.copy(sectionBuffer, w * l * sh * 5 / 2, offsetLight, offsetSkyLight + w * l * sh / 2);
          this.sections[i].load(sectionBuffer);
        }
      }
      data.copy(this.biome, w * l * sectionCount * chunkCount * 3);

      if (data.length != SECTION_SIZE * chunkCount + w * l) throw new Error('Data buffer not correct size (was ' + data.length + ', expected ' + BUFFER_SIZE + ')');
    }
  }]);

  return Chunk;
}();
//# sourceMappingURL=../../maps/pc/1.8/chunk.js.map
