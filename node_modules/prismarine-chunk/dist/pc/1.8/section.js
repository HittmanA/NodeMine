'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _require = require('uint4'),
    readUInt4LE = _require.readUInt4LE,
    writeUInt4LE = _require.writeUInt4LE;

var w = 16;
var l = 16;
var sh = 16; //section height

var SECTION_SIZE = w * l * sh * 3;

var getArrayPosition = function getArrayPosition(pos) {
  return pos.x + w * (pos.z + l * pos.y);
};

var getBlockCursor = function getBlockCursor(pos) {
  return getArrayPosition(pos) * 2.0;
};

var getBlockLightCursor = function getBlockLightCursor(pos) {
  return getArrayPosition(pos) * 0.5 + w * l * sh * 2;
};

var getSkyLightCursor = function getSkyLightCursor(pos) {
  return getArrayPosition(pos) * 0.5 + w * l * sh / 2 * 5;
};

var Section = function () {
  function Section() {
    _classCallCheck(this, Section);

    this.data = new Buffer(SECTION_SIZE);
    this.data.fill(0);
  }

  _createClass(Section, [{
    key: 'initialize',
    value: function initialize(iniFunc) {
      var skylight = w * l * sh / 2 * 5;
      var light = w * l * sh * 2;
      var n = 0;
      for (var y = 0; y < sh; y++) {
        for (var z = 0; z < w; z++) {
          for (var x = 0; x < l; x++, n++) {
            var block = iniFunc(x, y, z, n);
            if (block == null) continue;
            this.data.writeUInt16LE(block.type << 4 | block.metadata, n * 2);
            writeUInt4LE(this.data, block.light, n * 0.5 + light);
            writeUInt4LE(this.data, block.skyLight, n * 0.5 + skylight);
          }
        }
      }
    }
  }, {
    key: 'getBiomeColor',
    value: function getBiomeColor(pos) {
      return {
        r: 0,
        g: 0,
        b: 0
      };
    }
  }, {
    key: 'setBiomeColor',
    value: function setBiomeColor(pos, r, g, b) {}
  }, {
    key: 'getBlockType',
    value: function getBlockType(pos) {
      var cursor = getBlockCursor(pos);
      return this.data.readUInt16LE(cursor) >> 4;
    }
  }, {
    key: 'getBlockData',
    value: function getBlockData(pos) {
      var cursor = getBlockCursor(pos);
      return this.data.readUInt16LE(cursor) & 15;
    }
  }, {
    key: 'getBlockLight',
    value: function getBlockLight(pos) {
      var cursor = getBlockLightCursor(pos);
      return readUInt4LE(this.data, cursor);
    }
  }, {
    key: 'getSkyLight',
    value: function getSkyLight(pos) {
      var cursor = getSkyLightCursor(pos);
      return readUInt4LE(this.data, cursor);
    }
  }, {
    key: 'setBlockType',
    value: function setBlockType(pos, id) {
      var cursor = getBlockCursor(pos);
      var data = this.getBlockData(pos);
      this.data.writeUInt16LE(id << 4 | data, cursor);
    }
  }, {
    key: 'setBlockData',
    value: function setBlockData(pos, data) {
      var cursor = getBlockCursor(pos);
      var id = this.getBlockType(pos);
      this.data.writeUInt16LE(id << 4 | data, cursor);
    }
  }, {
    key: 'setBlockLight',
    value: function setBlockLight(pos, light) {
      var cursor = getBlockLightCursor(pos);
      writeUInt4LE(this.data, light, cursor);
    }
  }, {
    key: 'setSkyLight',
    value: function setSkyLight(pos, light) {
      var cursor = getSkyLightCursor(pos);
      writeUInt4LE(this.data, light, cursor);
    }
  }, {
    key: 'dump',
    value: function dump() {
      return this.data;
    }
  }, {
    key: 'load',
    value: function load(data) {
      if (!Buffer.isBuffer(data)) throw new Error('Data must be a buffer');
      if (data.length != SECTION_SIZE) throw new Error('Data buffer not correct size (was ' + data.length + ', expected ' + SECTION_SIZE + ')');
      this.data = data;
    }
  }]);

  return Section;
}();

Section.w = w;
Section.l = l;
Section.sh = sh;
Section.SECTION_SIZE = SECTION_SIZE;

module.exports = Section;
//# sourceMappingURL=../../maps/pc/1.8/section.js.map
