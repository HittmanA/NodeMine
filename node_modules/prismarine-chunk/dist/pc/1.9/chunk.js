'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var w = 16;
var l = 16;
var h = 256;

var BUFFER_SIZE = w * l * h * 3 + w * l;

var ProtoDef = require('protodef').ProtoDef;

var _require = require('uint4'),
    readUInt4LE = _require.readUInt4LE,
    writeUInt4LE = _require.writeUInt4LE;

module.exports = loader;

function loader(mcVersion) {
  Block = require('prismarine-block')(mcVersion);

  // MC counts the longs, protodef wants the bytes. This is responsible for that conversion.
  var longToByte = [function (buffer, offset, typeArgs) {
    //readLongToByte
    var results = this.read(buffer, offset, typeArgs.type, {});
    return {
      value: Math.ceil(results.value * 8),
      size: results.size
    };
  }, function (value, buffer, offset, typeArgs) {
    //writeLongToByte
    return this.write(value / 8, buffer, offset, typeArgs.type, {});
  }, function (value, typeArgs) {
    //sizeOfLongToByte
    return this.sizeOf(value / 8, typeArgs.type, {});
  }];

  var p = ["container", [{
    "name": "bitsPerBlock",
    "type": "u8"
  }, {
    "name": "palette",
    "type": ["array", {
      "type": "varint",
      "countType": "varint"
    }]
  }, {
    "name": "dataArray",
    "type": ["buffer", {
      "countType": "longToByte",
      "countTypeArgs": {
        "type": "varint"
      }
    }]
  }, {
    "name": "blockLight",
    "type": ["buffer", {
      "count": 16 * 16 * 16 / 2
    }]
  }, {
    "name": "skyLight",
    "type": ["buffer", {
      "count": 16 * 16 * 16 / 2
    }]
  }]];

  Chunk.packingProtocol = new ProtoDef();
  Chunk.packingProtocol.addType('longToByte', longToByte);
  Chunk.packingProtocol.addType('section', p);

  Chunk.w = w;
  Chunk.l = l;
  Chunk.h = h;
  Chunk.BUFFER_SIZE = BUFFER_SIZE;
  return Chunk;
}

var Block;

var exists = function exists(val) {
  return val !== undefined;
};

var getArrayPosition = function getArrayPosition(pos) {
  return pos.x + w * (pos.z + l * pos.y);
};

var getBlockCursor = function getBlockCursor(pos) {
  return getArrayPosition(pos) * 2.0;
};

var getBlockLightCursor = function getBlockLightCursor(pos) {
  return getArrayPosition(pos) * 0.5 + w * l * h * 2;
};

var getSkyLightCursor = function getSkyLightCursor(pos) {
  return getArrayPosition(pos) * 0.5 + w * l * h / 2 * 5;
};

var getBiomeCursor = function getBiomeCursor(pos) {
  return w * l * h * 3 + pos.z * w + pos.x;
};

var Chunk = function () {
  function Chunk() {
    _classCallCheck(this, Chunk);

    this.data = new Buffer(BUFFER_SIZE);
    this.data.fill(0);
  }

  _createClass(Chunk, [{
    key: 'initialize',
    value: function initialize(iniFunc) {
      var skylight = w * l * h / 2 * 5;
      var light = w * l * h * 2;
      var biome = w * l * h * 3 - 1;
      var n = 0;
      for (var y = 0; y < h; y++) {
        for (var z = 0; z < w; z++) {
          for (var x = 0; x < l; x++, n++) {
            if (y == 0) biome++;
            var block = iniFunc(x, y, z, n);
            if (block == null) continue;
            this.data.writeUInt16LE(block.type << 4 | block.metadata, n * 2);
            writeUInt4LE(this.data, block.light, n * 0.5 + light);
            writeUInt4LE(this.data, block.skyLight, n * 0.5 + skylight);
            if (y == 0) {
              this.data.writeUInt8(block.biome.id || 0, biome);
            }
          }
        }
      }
    }
  }, {
    key: 'getBlock',
    value: function getBlock(pos) {
      var block = new Block(this.getBlockType(pos), this.getBiome(pos), this.getBlockData(pos));
      block.light = this.getBlockLight(pos);
      block.skyLight = this.getSkyLight(pos);
      return block;
    }
  }, {
    key: 'setBlock',
    value: function setBlock(pos, block) {
      if (exists(block.type)) this.setBlockType(pos, block.type);
      if (exists(block.metadata)) this.setBlockData(pos, block.metadata);
      if (exists(block.biome)) this.setBiome(pos, block.biome.id);
      if (exists(block.skyLight)) this.setSkyLight(pos, block.skyLight);
      if (exists(block.light)) this.setBlockLight(pos, block.light);
    }
  }, {
    key: 'getBiomeColor',
    value: function getBiomeColor(pos) {
      // polyfill
      return {
        r: 0,
        g: 0,
        b: 0
      };
    }
  }, {
    key: 'setBiomeColor',
    value: function setBiomeColor(pos, r, g, b) {
      // polyfill
    }
  }, {
    key: 'getBlockType',
    value: function getBlockType(pos) {
      var cursor = getBlockCursor(pos);
      return this.data.readUInt16LE(cursor) >> 4;
    }
  }, {
    key: 'getBlockData',
    value: function getBlockData(pos) {
      var cursor = getBlockCursor(pos);
      return this.data.readUInt16LE(cursor) & 15;
    }
  }, {
    key: 'getBlockLight',
    value: function getBlockLight(pos) {
      var cursor = getBlockLightCursor(pos);
      return readUInt4LE(this.data, cursor);
    }
  }, {
    key: 'getSkyLight',
    value: function getSkyLight(pos) {
      var cursor = getSkyLightCursor(pos);
      return readUInt4LE(this.data, cursor);
    }
  }, {
    key: 'getBiome',
    value: function getBiome(pos) {
      var cursor = getBiomeCursor(pos);
      return this.data.readUInt8(cursor);
    }
  }, {
    key: 'setBlockType',
    value: function setBlockType(pos, id) {
      var cursor = getBlockCursor(pos);
      var data = this.getBlockData(pos);
      this.data.writeUInt16LE(id << 4 | data, cursor);
    }
  }, {
    key: 'setBlockData',
    value: function setBlockData(pos, data) {
      var cursor = getBlockCursor(pos);
      var id = this.getBlockType(pos);
      this.data.writeUInt16LE(id << 4 | data, cursor);
    }
  }, {
    key: 'setBlockLight',
    value: function setBlockLight(pos, light) {
      var cursor = getBlockLightCursor(pos);
      writeUInt4LE(this.data, light, cursor);
    }
  }, {
    key: 'setSkyLight',
    value: function setSkyLight(pos, light) {
      var cursor = getSkyLightCursor(pos);
      writeUInt4LE(this.data, light, cursor);
    }
  }, {
    key: 'setBiome',
    value: function setBiome(pos, biome) {
      var cursor = getBiomeCursor(pos);
      this.data.writeUInt8(biome, cursor);
    }
  }, {
    key: 'dump',
    value: function dump() {
      //OLD/INTERNAL FORMAT:
      //The first w*l*h*2 bytes are blocks, each of which are shorts.
      //After that, the first w*l*h*0.5 bytes are block-light-levels, each half-bytes.
      //Next, the first w*l*h*0.5 bytes are sky-light-levels, each half-bytes.
      //Finally, the next w*l bytes are biomes.

      var outputBuffer = Buffer.alloc(0);
      var chunkBlocks = Chunk.l * Chunk.w * 16;
      var blockLightStart = Chunk.l * Chunk.w * Chunk.h * 2;
      var skyLightStart = blockLightStart + Chunk.l * Chunk.w * Chunk.h / 2;
      var biomestart = skyLightStart + Chunk.l * Chunk.w * Chunk.h / 2;

      for (var y = 0; y < 16; y++) {
        var chunkapp = Chunk.packingProtocol.createPacketBuffer('section', {
          bitsPerBlock: 13,
          palette: [],
          dataArray: this.packBlockData(this.data.slice(y * chunkBlocks * 2, (y + 1) * chunkBlocks * 2), 13),
          blockLight: this.data.slice(blockLightStart + y * chunkBlocks / 2, blockLightStart + (y + 1) * chunkBlocks / 2),
          skyLight: this.data.slice(skyLightStart + y * chunkBlocks / 2, skyLightStart + (y + 1) * chunkBlocks / 2)
        });
        outputBuffer = Buffer.concat([outputBuffer, chunkapp]);
      }

      var ret = Buffer.concat([outputBuffer, this.data.slice(biomestart, biomestart + Chunk.l * Chunk.w)]);
      //console.log(ret.length);
      return ret;
    }
  }, {
    key: 'packBlockData',
    value: function packBlockData(rawdata, bitsPerBlock) {
      var blockCount = Chunk.l * Chunk.w * 16;
      var resultantBuffer = Buffer.alloc(blockCount * bitsPerBlock / 8 + 4);
      //We have to write very slightly past the end of the file, so we tack on 4 bytes.
      //We'll drop them at the end.
      for (var block = 0; block < blockCount; block++) {
        //Gather and reverse the block data
        var reversedblockdata = this.reverseBits(rawdata.readUInt16LE(block * 2), 16) >>> 3;
        //Determine the start-bit for the block.
        var startbit = block * bitsPerBlock;
        //Determine the start-byte for that bit.
        var startbyte = Math.floor(startbit / 8);
        //Read 4 bytes after that start byte.
        var existingdata = resultantBuffer.readUInt32BE(startbyte);
        //if (reversedblockdata == 0b0000100000000000)
        //	console.log("existing: " + this.padbin(existingdata, 32));
        //Where are we writing to, in the current bit?
        var localbit = startbit % 8;
        //Bit-shift the raw data into alignment:
        var aligneddata = reversedblockdata << 32 - bitsPerBlock - localbit;
        //if (reversedblockdata == 0b0000100000000000)
        //	console.log("aligned: " + this.padbin(aligneddata, 32));
        //Paste aligned data onto existing data
        var newdata = existingdata | aligneddata;
        //Write data back into buffer:
        resultantBuffer.writeUInt32BE(newdata >>> 0, startbyte);
      }

      //now, we jumble: (and we're sure to drop those extra 4 bytes!)
      var jumbledBuffer = Buffer.alloc(resultantBuffer.length - 4);
      for (var _l = 0; _l < jumbledBuffer.length; _l += 8) {
        //Load the long
        var longleftjumbled = resultantBuffer.readUInt32BE(_l);
        var longrightjumbled = resultantBuffer.readUInt32BE(_l + 4);
        //Write in reverse order -- flip bits by using little endian.
        jumbledBuffer.writeInt32BE(this.reverseBits(longrightjumbled, 32), _l);
        jumbledBuffer.writeInt32BE(this.reverseBits(longleftjumbled, 32), _l + 4);
      }
      return jumbledBuffer;
    }
  }, {
    key: 'reverseBits',
    value: function reverseBits(data, n) {
      var datau = data >>> 0; //Coerce unsigned.
      var storage = 0;
      for (var i = 0; i < n; i++) {
        storage = storage | datau & 1;
        if (i != n - 1) {
          storage = storage << 1;
          datau = datau >>> 1;
        }
      }
      return storage;
    }

    /*Debuggery
    padbin(num, len=32) {
      var s = (num >>> 0).toString(2);
      while (s.length < len) s = "0" + s;
      return s;
     }
     */

  }, {
    key: 'load',
    value: function load(data) {
      var bitMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0xFFFF;

      var unpackeddata = this.unpackChunkData(data, bitMap);
      if (!Buffer.isBuffer(unpackeddata)) throw new Error('Data must be a buffer');
      if (unpackeddata.length != BUFFER_SIZE) throw new Error('Data buffer not correct size (was ' + unpackeddata.length + ', expected ' + BUFFER_SIZE + ')');
      this.data = unpackeddata;
    }
  }, {
    key: 'unpackChunkData',
    value: function unpackChunkData(chunk, bitMap) {
      var offset = 0;
      var chunkBlocks = Chunk.l * Chunk.w * 16;
      var blockLightStart = Chunk.l * Chunk.w * Chunk.h * 2;
      var skyLightStart = blockLightStart + Chunk.l * Chunk.w * Chunk.h / 2;
      var biomestart = skyLightStart + Chunk.l * Chunk.w * Chunk.h / 2;

      var newBuffer = Buffer.alloc(BUFFER_SIZE);

      for (var y = 0; y < 16; y++) {
        var blocksAddition = void 0;
        var blocklightsAddition = void 0;
        var skylightsAddition = void 0;
        if ((bitMap >> y & 1) == 1) {
          var _readSection = this.readSection(chunk.slice(offset)),
              size = _readSection.size,
              value = _readSection.value;

          offset += size;
          blocksAddition = this.eatPackedBlockLongs(value.dataArray, value.palette, value.bitsPerBlock);
          blocklightsAddition = value.blockLight;
          skylightsAddition = value.skyLight;
        } else {
          //If a chunk is skipped, we'll just fill with existing data.
          blocksAddition = this.data.slice(y * chunkBlocks * 2, (y + 1) * chunkBlocks * 2);
          blocklightsAddition = this.data.slice(blockLightStart + y * chunkBlocks / 2, blockLightStart + (y + 1) * chunkBlocks / 2);
          skylightsAddition = this.data.slice(skyLightStart + y * chunkBlocks / 2, skyLightStart + (y + 1) * chunkBlocks / 2);
        }
        blocksAddition.copy(newBuffer, y * chunkBlocks * 2);
        blocklightsAddition.copy(newBuffer, blockLightStart + y * chunkBlocks / 2);
        skylightsAddition.copy(newBuffer, skyLightStart + y * chunkBlocks / 2);
      }
      if (bitMap == 0xFFFF) {
        chunk.slice(chunk.length - 256).copy(newBuffer, biomestart);
      }
      return newBuffer;
    }
  }, {
    key: 'readSection',
    value: function readSection(section) {
      try {
        return Chunk.packingProtocol.read(section, 0, 'section', {});
      } catch (e) {
        e.message = 'Read error for ' + e.field + ' : ' + e.message;
        throw e;
      }
    }

    //Simplified eatPackedBlockLongs Algorithm

  }, {
    key: 'eatPackedBlockLongs',
    value: function eatPackedBlockLongs(rawBuffer, palette, bitsPerBlock) {
      //The critical problem is that the internal order of each long is opposite to the organizational order of the longs
      //This is easily fixed by flipping the order of the longs.
      //Therefore, we will read 4 bytes at a time, bit-flip them, and write them into a new buffer.
      //From there, the old algorithm for reading will work just fine, we don't even have to consider the existence of the longs anymore.
      //A major side-effect, though, is that all of the internal block-datas will be flipped, so we have to flip them again before extracting data.
      var unjumbledBuffer = Buffer.alloc(rawBuffer.length);
      for (var _l2 = 0; _l2 < rawBuffer.length; _l2 += 8) {
        //Load the long

        var longleftjumbled = rawBuffer.readUInt32BE(_l2);
        var longrightjumbled = rawBuffer.readUInt32BE(_l2 + 4);
        //Write in reverse order

        unjumbledBuffer.writeInt32BE(this.reverseBits(longrightjumbled, 32), _l2);
        unjumbledBuffer.writeInt32BE(this.reverseBits(longleftjumbled, 32), _l2 + 4);
      }

      var blockCount = unjumbledBuffer.length * 8 / bitsPerBlock;
      var resultantBuffer = Buffer.alloc(blockCount * 2);
      var localBit = 0;

      for (var block = 0; block < blockCount; block++) {
        //Determine the start-bit for the block.
        var bit = block * bitsPerBlock;
        //Determine the start-byte for that bit.
        var targetbyte = Math.floor(bit / 8);

        //Read a 32-bit section surrounding the targeted block

        var datatarget = unjumbledBuffer.readUInt32BE(targetbyte, true);
        //console.log(":");
        //console.log(this.padbin(aligneddata,32));

        //Determine the start bit local to the datatarget.
        var localbit = bit % 8;

        //Chop off uninteresting bits, then shift interesting region to the end of the bit-buffer. Reverse the bits when done

        var paletteid = this.reverseBits(datatarget << localbit >>> 32 - bitsPerBlock, bitsPerBlock);

        //console.log(this.padbin(paletteid, 32));


        //Grab the data from the palette
        var palettedata = paletteid;
        if (palette.length != 0) palettedata = palette[paletteid];
        var data = palettedata & 15;
        var id = palettedata >>> 4;
        resultantBuffer.writeUInt16LE(id << 4 | data, block * 2);
      }
      return resultantBuffer;
    }
  }]);

  return Chunk;
}();
//# sourceMappingURL=../../maps/pc/1.9/chunk.js.map
