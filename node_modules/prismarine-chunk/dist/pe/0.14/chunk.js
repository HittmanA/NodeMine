'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var w = 16;
var l = 16;
var h = 128;
var BLOCK_DATA_SIZE = w * l * h;
var REGULAR_DATA_SIZE = BLOCK_DATA_SIZE / 2;
var SKYLIGHT_DATA_SIZE = BLOCK_DATA_SIZE / 2;
var BLOCKLIGHT_DATA_SIZE = BLOCK_DATA_SIZE / 2;
var ADDITIONAL_DATA_SIZE_DIRTY = w * l;
var ADDITIONAL_DATA_SIZE_COLOR = w * l * 4;
var BUFFER_SIZE = BLOCK_DATA_SIZE + REGULAR_DATA_SIZE + SKYLIGHT_DATA_SIZE + BLOCKLIGHT_DATA_SIZE + ADDITIONAL_DATA_SIZE_COLOR + ADDITIONAL_DATA_SIZE_DIRTY;

var readUInt4LE = require('uint4').readUInt4LE;
var writeUInt4LE = require('uint4').writeUInt4LE;

module.exports = loader;

function loader(mcVersion) {
  Block = require('prismarine-block')(mcVersion);
  Chunk.w = w;
  Chunk.l = l;
  Chunk.h = h;
  Chunk.BUFFER_SIZE = BUFFER_SIZE;
  return Chunk;
}

var Block;

function exists(val) {
  return val !== undefined;
}

var getArrayPosition = function getArrayPosition(pos) {
  return pos.x + w * (pos.z + l * pos.y);
};

var getBlockCursor = function getBlockCursor(pos) {
  return getArrayPosition(pos);
};

var getBlockDataCursor = function getBlockDataCursor(pos) {
  return BLOCK_DATA_SIZE + getArrayPosition(pos) * 0.5;
};

var getBlockLightCursor = function getBlockLightCursor(pos) {
  return BLOCK_DATA_SIZE + REGULAR_DATA_SIZE + getArrayPosition(pos) * 0.5;
};

var getSkyLightCursor = function getSkyLightCursor(pos) {
  return BLOCK_DATA_SIZE + REGULAR_DATA_SIZE + SKYLIGHT_DATA_SIZE + getArrayPosition(pos) * 0.5;
};

var getHeightMapCursor = function getHeightMapCursor(pos) {
  return BLOCK_DATA_SIZE + REGULAR_DATA_SIZE + SKYLIGHT_DATA_SIZE + BLOCKLIGHT_DATA_SIZE + pos.z * w + pos.x;
};

var getBiomeCursor = function getBiomeCursor(pos) {
  return BLOCK_DATA_SIZE + REGULAR_DATA_SIZE + SKYLIGHT_DATA_SIZE + BLOCKLIGHT_DATA_SIZE + ADDITIONAL_DATA_SIZE_DIRTY + (pos.z * w + pos.x) * 4;
};

var Chunk = function () {
  function Chunk() {
    _classCallCheck(this, Chunk);

    this.data = new Buffer(BUFFER_SIZE);

    this.data.fill(0);
  }

  _createClass(Chunk, [{
    key: 'initialize',
    value: function initialize(iniFunc) {
      var p = new Vec3(0, 0, 0);
      for (p.y = 0; p.y < h; p.y++) {
        for (p.z = 0; p.z < w; p.z++) {
          for (p.x = 0; p.x < l; p.x++) {
            var block = iniFunc(p.x, p.y, p.z);
            this.setBlock(pos, block);
          }
        }
      }
    }
  }, {
    key: 'getBlock',
    value: function getBlock(pos) {
      var block = new Block(this.getBlockType(pos), this.getBiome(pos), this.getBlockData(pos));
      block.light = this.getBlockLight(pos);
      block.skyLight = this.getSkyLight(pos);
      return block;
    }
  }, {
    key: 'setBlock',
    value: function setBlock(pos, block) {
      if (exists(block.type)) this.setBlockType(pos, block.type);
      if (exists(block.metadata)) this.setBlockData(pos, block.metadata);
      if (exists(block.biome)) this.setBiome(pos, block.biome.id);
      if (exists(block.skyLight)) this.setSkyLight(pos, block.skyLight);
      if (exists(block.light)) this.setBlockLight(pos, block.light);
    }
  }, {
    key: 'getBlockType',
    value: function getBlockType(pos) {
      return this.data.readUInt8(getBlockCursor(pos));
    }
  }, {
    key: 'setBlockType',
    value: function setBlockType(pos, id) {
      this.data.writeUInt8(id, getBlockCursor(pos));
    }
  }, {
    key: 'getBlockData',
    value: function getBlockData(pos) {
      return readUInt4LE(this.data, getBlockDataCursor(pos));
    }
  }, {
    key: 'setBlockData',
    value: function setBlockData(pos, data) {
      writeUInt4LE(this.data, data, getBlockDataCursor(pos));
    }
  }, {
    key: 'getBlockLight',
    value: function getBlockLight(pos) {
      return readUInt4LE(this.data, getBlockLightCursor(pos));
    }
  }, {
    key: 'setBlockLight',
    value: function setBlockLight(pos, light) {
      writeUInt4LE(this.data, light, getBlockLightCursor(pos));
    }
  }, {
    key: 'getSkyLight',
    value: function getSkyLight(pos) {
      return readUInt4LE(this.data, getSkyLightCursor(pos));
    }
  }, {
    key: 'setSkyLight',
    value: function setSkyLight(pos, light) {
      writeUInt4LE(this.data, light, getSkyLightCursor(pos));
    }
  }, {
    key: 'getBiomeColor',
    value: function getBiomeColor(pos) {
      var color = this.data.readInt32BE(getBiomeCursor(pos)) & 0xFFFFFF;

      return {
        r: color >> 16,
        g: color >> 8 & 0xFF,
        b: color & 0xFF
      };
    }
  }, {
    key: 'setBiomeColor',
    value: function setBiomeColor(pos, r, g, b) {
      this.data.writeInt32BE(this.data.readInt32BE(getBiomeCursor(pos)) & 0xFF000000 | (r & 0xFF) << 16 | (g & 0xFF) << 8 | b & 0XFF, getBiomeCursor(pos));
    }
  }, {
    key: 'getBiome',
    value: function getBiome(pos) {
      return (this.data.readInt32BE(getBiomeCursor(pos)) & 0xFF000000) >> 24;
    }
  }, {
    key: 'setBiome',
    value: function setBiome(pos, id) {
      this.data.writeInt32BE(this.data.readInt32BE(getBiomeCursor(pos)) & 0xFFFFFF | id << 24, getBiomeCursor(pos));
    }
  }, {
    key: 'getHeight',
    value: function getHeight(pos) {
      return this.data.readUInt8(getHeightMapCursor(pos, value));
    }
  }, {
    key: 'setHeight',
    value: function setHeight(pos, value) {
      this.data.writeUInt8(value, getHeightMapCursor(pos));
    }
  }, {
    key: 'load',
    value: function load(data) {
      if (!Buffer.isBuffer(data)) throw new Error('Data must be a buffer');
      if (data.length != BUFFER_SIZE) throw new Error('Data buffer not correct size (was ' + data.length + ', expected ' + BUFFER_SIZE + ')');
      this.data = data;
    }
  }, {
    key: 'dump',
    value: function dump() {
      return this.data;
    }
  }]);

  return Chunk;
}();
//# sourceMappingURL=../../maps/pe/0.14/chunk.js.map
